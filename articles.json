[
    {
        "id": 0,
        "description": "Jest to artykuł poświęcony budowie javy. Po przeczytaniu go, będziesz znać podstawy składni javy.",
        "content": "<h2>Postawowa struktura</h2>⁣⁣ Każda funkcja w pliku z rozszerzeniem .java, w odróżnieniu od c++ czy pythona musi być zawarta w klasie. Klasa musi mieć tą samą nazwę co plik, w innym wypadku może wyskoczy error. ⁣⁣ Jeżeli ktoś miał do czynienia z programowaniem to wie, że niektóre języki mają funkcje główne, które są urachamiane jako pierwsze po włączeniu programu. W przypadku javy to wygląda bardzo podobnie,⁣⁣ podstawową funkcją dla java jest <span style=\"font-weight: 700;\">public static void main(String[] args)</span> <pre>⁣⁣ <code class=\"hljs java\">public class Klasa{\n    public static void main(String[] args){\n        System.out.println(\"Hello world!\");\n    }\n}\n </code><code class=\"hljs\"> Output:\nHello world!\n </code> </pre> Jeżeli nie mieliście styczności z programowaniem to najprawdopodobniej nie wiecie co oznaczają takie słowa jak <b>static</b> czy <b>void</b>. Dlatego też je wam wytłumaczę! <h2>Typy funkcji</h2> Istnieje wiele typów funcji, statyczne, zwracające wartość, czy też takie które nic nie zwracają. Chwilowo zacznijmy od tego w jaki sposób zadeklarowuje się funkcję. Na podstawie ostatniej funckji i tej teoretycznej budowy przeanalizujcie to sami. <pre> <code class=\"hljs\"> [modyfikator dostępu] [słowo kluczowe] [typ funckji] [nazwa]([argumenty]) </code> </pre> Poniżej macie tabelę przedstawiającą modyfikatory dostępu i ich znaczenia. <table> <thead> <tr> <th class=\"shadowedTh\">Modyfikator</th> <th class=\"shadowedTh\">Znaczenie</th> </tr> </thead> <tbody> <tr> <td class=\"shadowedTd\">private</td> <td>Funkcja prywatna, nie można jej wywołać w innej klasie niż w jej rodzimej.</td> </tr> <tr> <td class=\"shadowedTd\">public</td> <td>Funkcja publiczna, można ją wywołać w innej klasie.</td> </tr> <tr> <td class=\"shadowedTd\">protected</td> <td>Funkcja z tym modyfikatorem może być użyta tylko w tej klasie albo w klasach dziedziczących tą klase.</td> </tr> </tbody> </table> <br> Po modyfikatorze dostępu możemy jeszcze dopisać <b>słówko kluczowe</b>. Są one bardzo potrzebne w javie, lecz są również dosyć mocno zaawansowane. Słówko kluczowe <b>static</b> powoduje że możemy odwłać się do funkcji bądź zmiennej bez tworzenia obiektu, a <b>final</b> tworzy <i>stałą</i> - czyli schowek którego nie można zmienić bądź funkcję której nie można dziedziczyć.",
        "title": "Budowa języka - javy"
    },
    {
        "id": 1,
        "description": "Artyuł ten poświęcony jest słówku kluczowym static. Po przeczytaniu go powinieneś wiedzieć co nam daje te słówko i gdzie je stosować.",
        "content": "⁣⁣<h2>Co oznacza Static?</h2> Static to taki atrybut który można nadać metodzie, bądź zmiennej lub stałej. Jednak co on nam daje? No daje dosyć sporo, bo dzięki niemu możemy przywoływać funckję bądź zmienne bez tworzenia niepotrzebnych <b>obiektów</b>. Co pozwala nam zaoszczędzić pare linijek w kodzie. Jednak w jakich przypadkach byśmy go używali? Dajmy na to że chcemy stworzyć metode która będzie pokazywałą użytkownikowi aplikacji komunikat. Wtedy tworzenie obiektu byłoby bardzo uciążliwe, dlatego używa się funkcji statycznych. Poniżej prosta funkcja z javy która pokazuje komunikat na adroidzie. <pre> <code class=\"hljs java\"> Toast.makeText(getContext(), \"Złe hasło!\", Toast.LENGTH_LONG).show(); </code> </pre> Jeżeli funkcja <i>makeText()</i> byłaby <b>niestatyczna</b>, wtedy musielibyśmy wprowadzić taki zapis: <pre> <code class=\"hljs java\"> Toast toast = new Toast();\n toast.makeText(getContext(), \"Złe hasło!\", Toast.LENGTH_LONG);\n toast.show(); </code> </pre> Jak widzicie pierwszy zabis jest o wiele korzystniejszy i bardziej praktyczny. <h2>Jak go używać?</h2> Załóżmy że chcemy napisać skomplikowany program który będzie się witał za każdym razym gdy użytkownik napisze <i>\"Hi!\"</i>. Jako iż poziom skomplikowania jest arcytrudny, to wytłumacze wam krok po kroku co my tu robimy! Najpierw używając klasy <b>Scanner</b>. Damy jej argument System.in co znaczy że będziemy operować na tekstcie pozyskanym od użytkownika. Jak sama nazwa wskazuje to co dostaje system, wchodzi w system. <pre> <code class=\"hljs java\"> Scanner scan = new Scanner(System.in); </code> </pre> Dobrze więc mamy już stworzony obiekt Scanner o nazwie scan który operuje na tym co wysłał użytkownik... Może więc teraz zapytamy się użytkownika o imię? <pre> <code class=\"hljs java\"> System.out.println(\"Przedstaw się!\");\n String name = scan.nextLine(); </code> </pre> Najpierw wyświetlamy na ekranie tekst <i>\"Przedstaw się!\"</i> a następnie tworzymy zmienną <b>name</b> która przyjmuje następną linie którą napisze użytkownik. Dobrze skoro znamy już jego imię to może niech się przywitamy? <pre> <code class=\"hljs java\"> System.out.println(\"Przywitaj się!\");\n String hi = scan.nextLine(); </code> </pre> Dobra najprostsza część za nami. Teraz stworzymy publiczną klase która będzie w sobie miała publiczną statyczną metode która zwraca napis <i>Hello</i> z doklejonym imieniem użytkownika. <pre> <code class=\"hljs java\"> public class Przywitanie{\n    public static String sayHello(String name){\n       return \"Hello\"+name+\"!\";\n    }\n } </code> </pre> Dobrze a więc skoro już mamy klasę <b>Przywitanie</b> to możemy się witać! wywołajmy ją takim kodem: <pre> <code class=\"hljs java\"> Przywitanie.sayHello(name); </code> </pre> Pamiętajmy że wcześniej <b>name</b> to była nasza zmienna która przechowuje imię. Jednak może sprawdzimy czy użytkownik naprawdę się przywitał, czy może był prostakiem bez klasy? Więc if'em sprawdze czy name jest równe <i>\"Hi!\"</i>. Użyje do tego metody <b>equals()</b>. <pre> <code class=\"hljs java\"> if(hi.equals(\"Hi!\")) System.out.println(Przywitanie.sayHello(name)); </code> </pre> Dobrze a więc teraz daje wam cały kod z dwoma klasami i wynikiem aplikacji! <pre> <code class=\"hljs java\"> public class Przedstaw{\n      public static String sayHello(String name){\n           return \"Hello \"+name+\"!\";\n      }\n }\n \n import java.util.Scanner;\n \n public class Main{\n       public static void main(String[] args){\n           Scanner scan = new Scanner(System.in);\n \n           System.out.println(\"Przedstaw się!\");\n           String name = scan.nextLine();\n \n           System.out.println(\"Przywitaj się!\");\n           String hi = scan.nextLine();\n \n           if(hi.equals(\"Hi!\")) System.out.println(Przedstaw.sayHello(name));\n       }\n }\n \n \n Output:\n \n Przedstaw się!\n Czarek\n Przywitaj się!\n Hi!\n Hello Czarek! </code> </pre>",
        "title": "Słówko kluczowe - Static⁣⁣⁣⁣"
    },
    {
        "id": 2,
        "description": "Po przeczytaniu tego artykułu będziesz wiedział co to słówko kluczowe finaj i jak je używać.",
        "content": "<h2>Jak działa final?</h2> Final to atrybut funkcji bądź wartości który tworzy ją stałą, czyli nie da się jej nadpisać ani zmienić. Jest przydatny w miejscach gdy chcemy aby użytkownik mógł określić rodzaj elementu w metodzie poprzez liczbę zawartą w zmiennej. Łatwiej owiele zrozumieć o co chodzi gdy do atrybutu metody o nazwie <i>\"elementType\"</i> nadamy wartość [klasa].bigElement którego wartość to liczba całkowita, zamiast napisać zwykłą liczbę. Jednak największym problemem nie jest napisanie liczby, a jej <b>zapamiętanie</b>! Jak już wspominałem nie da się zmienić wartości stałej(czyli \"zmiennej\" ze słówkiem kluczowym final). Ale najpierw zapytajmy się...<h2>Co to stała?</h2> Jeżeli ktoś z was uważał na fizyce to wie że stała to wartość która nie ulega zmianie, np. V = const, czyli prędkość na przestrzeni czasu jest stała, nie ulega zmianie. I w <b>TYM</b> cały szczegół. Zmienną można zmieniać a stałą nie! W javascrip'cie zmienne ustawia się słowem <b>var</b> które oznacza variable - zmienna, natomiast stałą słowem <b>const</b> czyli constans - stała. W javie każda wartość jest zmiennę jeżeli <b>NIE MA</b> wartości <b>final</b>. Czyli w takim przypadku wszystko pójdzie dobrze: <pre> <code class=\"hljs java\">public class Main{\n    static int i = 5;\n    public static void main(String[] args){\n        i = 8;\n    }\n} </code> </pre> Natomiast gdy zmienna i będzie stałą czyli zapis będzie wyglądać tak: <pre> <code class=\"hljs java\"> static final int i = 5; </code> </pre> Na ekranie wyrzuci nam <span style=\"color: #D0041f;\"><b>errora</b></span>. Dobra skoro już coś wiemy to przejdźmy do prostego projektu.<h2>Kod!</h2> Stworzymy program który będzie wyświetlał napis \"color\" w różnym kolorze, zależnie od wartości. Oczywiście użyjemy w klasie showColor stałych które będą określać kolor. Do zmieny koloru użyjemy <b>ASNI</b>. Jest to w skrócie standard do określania wyglądu terminala. Wpierw stworzymy 4 stałe, jedna będzie prywatna a trzy publiczne. Prywatna służyć nam będzie do ustawiania koloru na domyślny, a 3 publiczne do ustawiania koloru tekstu. <pre> <code class=\"hljs java\">public class showColor{\n    private static final String ANSI_RESET = \"\\u001B[0m\";\n    public static final String ANSI_RED = \"\\u001B[31m\";\n    public static final String ANSI_GREEN = \"\\u001B[32m\";\n    public static final String ANSI_BLUE = \"\\u001B[34m\";\n\n    public static void showColoredText(String text, String color){\n        System.out.println(color + text + ANSI_RESET);\n    }\n}</code> </pre> Teraz w głównej klasie wystarczy wywołać funkcję i napawać się owocem naszej pracy! <pre> <code class=\"hljs java\">public class Test{\n    public static void main(String[] args) {\n        Test2.showColoredText(\"Kocham jave\", Test2.ANSI_RED);\n        Test2.showColoredText(\"Fajne są te kwiatki\", Test2.ANSI_GREEN);\n        Test2.showColoredText(\"Twoje oczy są błękitne jak bezchmurne niebo ( ͡° ͜ʖ ͡°)\", Test2.ANSI_BLUE);\n    }\n} </code> </pre> <pre> <code class=\"hljs\">Output:\n<span style=\"color: red;\">Kocham jave</span>\n<span style=\"color: green;\">Fajne są te kwiatki</span>\n<span style=\"color: blue;\">Twoje oczy są błękitne jak bezchmurne niebo ( ͡° ͜ʖ ͡°)</span> </code> </pre>",
        "title": "Słówko kluczowe - final"
    },
    {
        "id": 3,
        "description": "Ten artykuł mówi o zmiennych, po przeczytaniu go będziesz wiedzieć jakie istnieją typy zmiennych w javie.",
        "content": "<h2>Co to zmienna?</h2> Zmienna w informatyce to tak jakby <i>\"szufladka\"</i> w pamięci podręcznej naszego komputera. Można ją dowolnie edytować, czyli na początku kodu można jej nadać wartość 5, w połowie 10 a na końcu 154. Zmienne są jedną z najważniejszych tworów w Javie. Nie ma żadnej funkcji bez zmiennej <b>Ż A D N E J</b>. W javascriptcie istnieje typ zmiennej który sam domyśla się jego typu i w <b>każdym</b> momencie możemy zmienić typ ów zmiennej, nazywa się <b>var</b>. W javie sprawa się komplikuje, ponieważ choć istnieje <b>var</b> w javie, to działa trochę inaczej. Poniżej będziesz mógł przeczytać o każdym typu zmiennej w javie. <h2>Zmienne liczbowe</h2> Zmienne liczbowe w javie dzielą się na zmienne <b>całkowite</b> i zmienne <b>rzeczywiste</b>. Różnica między nimi jest taka że w te drugie posiadają liczby po przecinku np. 2,5. <h4>Zmienne Całkowite</h4> Każdą zmienną deklaruje się w identyczny sposób, różniaca jest w jej wielkości w systemie i w jej zakresie. Poniżej umieściłem tabelę ze wszystkimi danymi: <table> <thead> <tr> <th class=\"shadowedTh\">Zmienna</th> <th class=\"shadowedTh\">Wielkość w pamięci podręcznej</th> <th class=\"shadowedTh\">Zakres</th> </tr> </thead> <tbody> <tr> <td class=\"shadowedTd\">byte</td> <td>1 bajt</td> <td>od -128 do 127</td> </tr> <tr> <td class=\"shadowedTd\">short</td> <td>2 bajt</td> <td>od -32 768 do 32 767</td> </tr> <tr> <td class=\"shadowedTd\">int</td> <td>4 bajt</td> <td>od -2 147 483 648 do 2 147 483 647</td> </tr> <tr> <td class=\"shadowedTd\">long</td> <td>8 bajt</td> <td>od -2^63 do (2^63)-1</td> </tr> </tbody> </table> <h4>Zmienne Rzeczywiste</h4> <table> <thead> <tr> <th class=\"shadowedTh\">Zmienna</th> <th class=\"shadowedTh\">Wielkość w pamięci podręcznej</th> <th class=\"shadowedTh\">Zakres</th> </tr> </thead> <tbody> <tr> <td class=\"shadowedTd\">float</td> <td>4 bajt</td> <td>maksymalnie około 6 liczb po przecinku</td> </tr> <tr> <td class=\"shadowedTd\">double</td> <td>8 bajt</td> <td>maksymalnie około 15 liczb po przecinku</td> </tr> </tbody> </table> <h2>Zmienne Znakowe</h2> Pamiętajmy nie w programowaniu nie ma samych liczb, czasem trzeba coś napisać na ekranie itp. Dlatego istnieją równierz zmienne posiadające znaki. W javie istnieją dwa typy zmiennych które przechowują znaki - pierwszą jest <b>char</b> posiada ona same pojedyńcze znaki. Nie może mieć dwóch znaków, lecz może posiadać tabulację, spację, enter itp. Następnym typem ciąg(łańcuch) znaków <b>String</b>. Może on posiadać jakąkolwiek ilość różnych znaków. Co <b>ważne</b> pojedyńcze znaki zapisujemy w apostrofach a ciągi znaków w cudzysłowie. <pre> <code class=\"hljs java\">char znak = 'c';\nString ciag = \"ciąg znaków\";</code> </pre> Istnieją równierz znaki specjalne które można utrzymać wpisując poniższe wartości: <table> <thead> <tr> <th class=\"shadowedTh\">Nazwa</th> <th class=\"shadowedTh\">Wartość</th> </tr> </thead> <tbody> <tr> <td class=\"shadowedTd\">\\t</td> <td>Tabulator</td> </tr> <tr> <td class=\"shadowedTd\">\\n</td> <td>Nowa linijka</td> </tr> <tr> <td class=\"shadowedTd\">\\r</td> <td>Carriage return</td> </tr> </tbody> </table> Jeżeli chcemy napisać jakiś znak typu cudzysłów czy apostrof to przed niego musimy dodać <i>\"\\\"</i>, aby kompilator wiedział że chodzi nam o tekst a nie o znak specjalny. <h2>Zmienne Prawda/Fałsz</h2> Doszliśmy do przedostatniego rodzaju zmiennych. Nazywają się - <b>boolean</b>. Przechowuje on albo <b>true</b> - czyli prawdę, albo <b>false</b> - fałsz. <h2>Zmienna Var</h2> Zmienna ów jest najnowszą zmienną w Javie. Powstała wraz z javą 10 i pozwala na <b>automatyczne</b> przypisanie typu zmiennej do wartości. Lecz nie da się zmieniać typu zmiennej dynamicznie. Jeżeli program raz ustawi typ zmiennej na int a potem nadamy tej zmiennej wartość z przecinkiem to otrzymamy error. <b>Co ciekawe</b> nie da się nazwać zmiennej nazwą typu zmiennej, <b>LECZ</b> występuje wyjątek z var. Powstał on ponieważ któś mógł posiadać w swoim programie zmienną o nazwie var przed tym jak wprowadzili ten typ zmiennej. Jeżeli nagle by odmówili możliwości nadawania takowych nazw zmiennym to niektóre programy by odmawiały posłuszeństwa i by potrzebowały nagłych zmian.",
        "title": "Typy zmiennych w Javie"
    },
    {
        "id": 4,
        "description": "Po przeczytaniu tego artykułu dowiesz się jak tworzyć metody w Javie i jak je przywoływać.",
        "content": "<h2>Co to jest Metoda</h2> Metoda to inaczej funkcja, musi ona zrobić dane zadanie gdy ją przywołamy. Ja lubię porównywać funkcję do pracownika budowy, np. takiego Zdzisia. Załóżmy sobie że w waszym mieście jest budowa, robotniką przywieźli cement w przyczepie tira. Pracownicy wypakowują ten cement i tutaj przychodzi <b>Zdzisiu</b>. Gdy wyładują dostatecznie cementu to wołają Zdzisia a ten z dostaje cement i na taczce go przywozi do miejsca docelowego. W bardzo podobny sposób działają funkcję w Javie. Załóżmy że mamy funckję która się nazywa <i>showText</i> i ona pokazuje tekst który jej damy na ekranie. Czyli wołamy <b>SHOOOW TEEEXT</b> i do łapy jej dajemy \"Hello World\". <h2>Tworzenie Metody</h2> Zbudujmy teraz wcześniejszą funckję. Musi przyjmować jakiś tekst, więc opowiedzmy na pytanie \"Jaki typ zmiennej jest używany do tekstu?\". Trudna pytanie... <b>STRING</b>. A więc nasza metoda będzie przyjmować Stringa i nazwie <i>text</i>. Fajnie jakby była <b>statycza</b> i <b>prywatna</b> byśmy mogli ją wywołać z głównej metody programu i byśmy nie mogli tej funkcji użyć w innej klasie. (Jeżeli nie wiesz o czym mówię to musisz zobaczyć te dwa artykuły: <a href=\"ciekawostka.html?id=1\"><b>Słówko kluczowe - Static⁣⁣⁣⁣</b></a> <a href=\"ciekawostka.html?id=0\"><b>Budowa języka - javy</b></a>) Potem używając funckji <b>System.out.printl()</b> program będzie wyświetlać ów zmienną na ekranie. Dobrze ale jeszcze jest coś ważnego... Jaki typ funckji użyć? No tutaj nie ma trudnego wyboru, funkcje mają takie same typy co zmienne, tylko istnieje dodatkowy typ <b>void</b>. Co dają nam typy funkcji? Każda funkcja nie licząc <b>void</b> coś zwraca. Musi nam coś dać i tutaj widać typ. Ponieważ typ String musi nam zwrócić napis, a int liczbę całkowitą. My użyjemy voida, ponieważ nie ma sensu zwracać cokolwiek skoro tylko chcemy wyświetlić ten tekst. <pre> <code class=\"hljs java\">private static void showText(String text){\n    System.out.println(text);\n}</code> </pre> <h2>Przywoływanie Funkcji</h2> Tutaj się zatrzymamy na dłużej, ponieważ istnieje wiele wyjątków. Zacznijmy od tego że w funkcji statycznej nie możemy przywołać funkcji z tej samej klasy jeżeli jest ona <b>niestatyczna!</b>. <pre> <code class=\"hljs java\"> public class test {\n    public static void main(String[] args) {       \n                    show();     \n                      }  \n                          private void show(){\n        System.out.println(\"Working\");\n    }   \n                     }</code> </pre> W przypadku takim jak powyżej, zobaczymy <span style=\"color: #D52F31\">error</span>. Ponieważ funkcja <i>show()</i> jest niestatyczna. Aby ją przywołać musimy utworzyć obiekt klasy i następnie z tej klasy przywołać ów funkcję. <pre> <code class=\"hljs java\"> test t = new test();\n t.show(); </code> </pre> Tak samo się przywołuje każdą funkcję niestatyczną w innych klasach. Jednak gdy nasza klasa jest niestatyczna i przywołujemy ją z klasy również niestatycznej wystarczy po prostu ją przywołać bez tworzenia obiektów. <pre> <code> show(); </code> </pre> Tak samo sytuacja wygląda jeżeli funkcja <i>show()</i> byłaby statyczna <pre> <code class=\"hljs java\">public class test {\n    public static void main(String[] args) {   \n                        show();      \n                }          \n              private static void show(){\n        System.out.println(\"Working\");\n    }               \n       }</code> </pre>",
        "title": "Metody w Javie"
    },
    {
        "id": 5,
        "description": "W tym artykule tłumacze jak odczytać tekst, bądź liczby z różnych źródeł w Javie.",
        "content": "<h2>Jak odczytywać tekst i liczby w Javie?</h2> Jest wiele sposobów na pozyskanie tekstu bądź liczby w Javie. Najpopularniejsze sposoby to użycie klas <i>Scanner</i> i <i>BufferedReader</i>, więc opowiem trochę o nich, czym się różnią i jak ich używać. Zacznijmy od tego jak je użyć. Aby użyć jakiejś wartości z ów klas trzeba stworzyć ich obiekt który przyjmuje w atrybutach z czego ma czytać. <pre> <code class=\"hljs java\">Scanner scan = new Scanner([z czego czytamy]);\n BufferedReader br = new BufferedReader(new InputStreamReader([z czego czytamy])); </code> </pre> I teraz zacznijmy od tego jakich metod użyć do czytania i jakie są różnice w naszych klasach. Aby odczytać tekst w tych klasach można użyć poniższych metod: <br> Dla Scannera <pre> <code class=\"hljs java\"> scan.nextLine();\n scan.next();\n scan.findInLine([czego szukamy]); </code> </pre> Metoda <b>nextLine()</b> czyta całą następną linie, <b>next()</b> następne słowo. Następna metoda szuka w linii tekstu jakiegoś ciągu znaków, jeżeli go znajdzie to zwaca ten ciąg znaków, w innym wypadku zwróci <b>null</b>. Dla BufferedReadera\" <pre> <code class=\"hljs java\"> br.readLine();\n br.read() </code> </pre> Pierwsza metoda zwraca linie tekstu, druga zaś liczbę. <h2>Jak czytać to co napisze użytkownik?</h2> aby przeczytać co napisze użytkownik musimy w argumencie obiektu klasy użyć <b>System.in</b>. Ta zmienna mówi o tym co wchodzi do systemu. <pre> <code class=\"hljs java\"> Scanner scan = new Scanner(System.in);\n BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); </code> </pre> Zakładając że chcemy aby użytkownik wybrał jedną z licz możemy zrobić taki program: <pre> <code class=\"hljs java\"> \/\/Dla Scanenra\n Scanner scan = new Scanner(System.in);\n System.out.print(\"Wybierz liczbę: \"); \n int liczba = scan.nextInt();\n System.out.println(liczba);\n \n //Dla BufferedReadera\n BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n System.out.print(\"Wybierz liczbę: \");\n int liczba = br.read();\n System.out.println(liczba);\n </code> </pre> <h2>Jak czytać z pliku?</h2> Jeżeli chcielibyśmy przeczytać zawartość pliku o nazwie <i>tekst.txt</i> który znajduje się w tym samym folderze co nasza klasa, wystarczy nadać obiektą następujący atrybut: <pre> <code class=\"hljs java\"> Scanner scan = new Scanner(new File(\"tekst.txt\"));\n BufferedReader br = new BufferedReader(new FileReader(\"tekst.txt\")); </code> </pre> Następnie aby wszystkie linie tekstu przeczytać w Scannerze należy użyć pętli while do której atrybutu należy przypisać metodę <i>scan.hasNextLine()</i>. Ta metoda zwraca <b>true</b> jeżeli nasz plik ma następną linijkę. Czyli ta pętla działa dopóki plik ma następną linijkę. Aby wyświetlić linie tekstu należy w środku pętli napisać <b>System.out.println(scan.nextLine())</b> <pre> <code class=\"hljs java\"> while(scan.hasNextLine()){\n \tSystem.out.println(scan.nextLine());\n } </code> </pre> W przypadtku BufferedReadera wygląda to troszkę inaczej. Możemy równierz użyć pętli <b>while</b>, ale tym razem będziemy sprawdzać w niej czy nasza linia nie jest <b>niczym</b>. Na początek stwórzmy zmienną <b>linia</b>. Następnie w argumencie pętli będziemy jej nadawać wartość br.readLine(), aby to zrobić wystarczy wyrażenie <b>linijka = br.readLine</b>. Teraz sprawdzamy czy nie równa się <b>null</b>. Po tym wystarczy wypisać zmienną linia na ekranie. <pre> <code class=\"hljs java\"> String linia;\n while((linia = br.readLine()) != null){\n \tSystem.out.println(linia);\n } </code> </pre>",
        "title": "Czytanie w Javie"
    },
    {
        "id": 6,
        "description": "Artykuł ten jest poświęcony klasom, po przeczytaniu tego artykułu będziesz znać podstawowe pojęcia związane z klasami i będziesz umiał pisać własne klasy.",
        "content": " <h2>Co to klasa?</h2> Klasa to zbiór zmiennych, stałych i metod. Istnieje wiele klas zawartych w samej javie, lecz wy równierz możecie swoją zrobić, bądź też <b>zimportować</b> od innych użytkowników. Jeżeli trochę programowaliście w javie, napewno znacie taki zapis: <pre> <code class=\"hljs java\"> public class main{\n } </code> </pre> Troszkę rozszyfruje ten zapis. Nietrudno zrozumieć że jest to klasa o nazwie <i>main</i>. Słowo public oznacza że jest to klasa publiczna, oznacza to że można jej użyć w innych klasach, lecz czy to znaczy że możemy użyć pisowni <pre> <code class=\"hljs java\"> private class main{\n } </code> </pre> No niby tak, niby nie. Bo z jednej strony to nie jest błąd, a z drugiej taka klasa jest po prostu <b>bezużyteczna</b>, a conajmniej tak twierdzi duża część programistów. <h2>Do czego używać klas?</h2> Zacznijmy od tego że klasy nam pięknie segregują program, nie mamy wszystkiego w pliku zawierającym <b>25 tysięcy</b> linii kodu. A więc, dlatego np. w specjalnych bibliotekach androidowskich do javy istnieje taka klasa jak Button. Można jej nadać kolor, szerokość, tekst i wiele innych rzeczy, aby następnie użyć funkcji która wsadza ją do jakiegoś <i>pojemnika</i>. Przybliże Ci może to na jakimś sensownych przykładzie. Załóżmy że mamy grę mmorpg i co jakiś czas musimy spawn'ować potwory. Aby wiedzieć co nieco o tym, to w konsoli servera wyświetlamy komunikat o tym jaki potwór poswtał, ile ma punktów zdrowia i na jakich koordynatach jest położony. W tym celu stworzymy klasę <b>Monster</b> która będzie posiadać trzy zmienne, hp, typ potwora i pozycje XY. <pre> <code class=\"hljs java\"> public class Monster {\n \n \tint hp;\n \tString type;\n \tint positionXY[] = new int[2];\n \n } </code> </pre> Dobrze więc teraz stwórzmy w naszej głównej klasie trochę potworów, jedego slime i jednego zombie. <pre> <code class=\"hljs java\"> public class Main{\n \n \tpublic static void main(String[] args){\n \n \t\tMonster slime = new Monster();\n \t\tslime.type = \"slime\";\n \t\tslime.hp = 50;\n \t\tslime.positionXY = new int[]{50, -15};\n \n \t\tMonster zombie = new Monster();\n \t\tzombie.type = \"zombie\";\n \t\t\tzombie.hp = 253;\n \t\tzombie.positionXY = new int[]{515, 732};\n \n \t}\n } </code> </pre> Stworzyliśmy w tym celu dwa obiekty klasy Monster. Jeden to slime a drugi to zombie. Oczywiście jak widzicie najpierw w zapisie obiektu wstawiamy klase, potem nazwę obiektu a po znaku równości słówko new i nazwę klasy z nawiasami... ale czy napewno? Zacznijmy od tego że zapis <b>new Monster()</b> to nie zapis klasy a <b>konstruktora</b>, ale o tym później. Tutaj możemy dać wiele rzeczy, np. w programowaniu na androida możemy użyć takiego zapisu. <pre> <code class=\"hljs java\"> Button przycisk = R.id.przycisk; </code> </pre> Ten napis tworzy obiekt do już <b>istniejącego</b> przycisku. <pre> <code class=\"hljs java\"> Button przycisk = new Button(); </code> </pre> Ten natomiast tworzy nowy przycisk. Jednak wróćmy do naszego kodu o potworach. Zmieniłem w danych obiektach zmienne, nadałem typ potwora, hp i lokalizacje na mapie. Aby odwołać się do zmiennej w danej klasie, po nazwie obiektu dopisałem kropkę z nazwą ów zmiennej. To oznacza dosłownie <i>\"Weź mi tą zmienną w tej o o tej klasie!\"</i>. Jako iż nasza pozycja jest tablicą to użyłem zapisu <b>new int[]{<span style=\"color: aqua\">X</span>, <span style=\"color: red;\">Y</span>}</b>, oznacza on że tworzymy nową tablicę przyjmującą typ int, która zawiara dane dwie liczby. Troszkę zawiłę, lecz gdy wiemy jak działają tablice to nie powinno być problemu. Teraz przyda nam się stworzyć zmienną która wyświetla nam komunikat związany ze spawnem danego moba. <pre> <code class=\"hljs java\"> public void spawnMonster(){\n \tSystem.out.println(\"Monster spawned!\");\n \tSystem.out.println(\"Type: \"+type);\n \tSystem.out.println(\"Hp: \"+hp);\n \tSystem.out.println(\"Position X = \"+positionXY[0]+\" Y = \"+positionXY[1]+\"\\n\");\n } </code> </pre> Aby to uczynić stworzyłem metoda <b>spawnMonster()</b>, jest ona publiczna lecz nie statyczna, nie może posiadać słówka kluczowego <b>static</b>, ponieważ musi się odnosić do danego obiektu. A jak dobrze wiemy, metoda statyczna nie może być wykonana poprzez obiekt. Funkcja nadaje komunikat o spawnie potwora, następnie mówi jaki on ma typ, hp, i pozycję. Aby <i>zrespić moba</i> wystarczy teraz użyć tej metody na obiekcie danego stwora. <pre> <code class=\"hljs java\"> [obiekt].spawnMonster(); </code> </pre> Nasz kod wygląda teraz w następujący sposób: <pre> <code class=\"hljs java\"> public class Main{\n \n \tpublic static void main(String[] args){\n \n \t\tMonster slime = new Monster();\n \t\tslime.type = \"slime\";\n \t\tslime.hp = 50;\n \t\tslime.positionXY = new int[]{50, -15};\n \t\tslime.spawnMonster();\n \n \t\tMonster zombie = new Monster();\n \t\tzombie.type = \"zombie\";\n \t\tzombie.hp = 253;\n \t\tzombie.positionXY = new int[]{515, 732};\n \t\tzombie.spawnMonster();\n \n \t}\n \n } </code> </pre> Niby wszystko git, ładnie wygląda, lecz zobaczcie. Aby dać tylk o 3 wartości głupiemu potworowi trzeba poświęcić aż <b>4 linie</b> kodu. A co jeżeli takich zmiennych by nie było 3 a np. 7? Wtedy z pomocą przychodzi...<h2>Konstruktor</h2> My nie tworzyliśmy kontruktora, lecz on sam się tworzył. Domyślny konstrukor dla naszej klasy to <b> Monster(); </b> i jest on tworzony automatycznie, więc nie musimy tworzyć takiej struktury w naszej klasie. <pre> <code class=\"hljs java\"> Monster(){\n } </code> </pre> Lecz możemy też tworzyć własne konstruktory która działają prawie jak funkcja void. Konstruktor może przyjmować argumenty i wykonywać z nimi działania. Dlatego po prostu nadawać argumenty będziemy w konstruktorze! A następnie nasze kochane zmienne z klasy podmienimy argumentami konstruktora. Będzie to wyglądać mniej więcej tak: <pre> <code class=\"hljs java\"> Monster(int hp, String type, int[] positionXY){\n \thp = hp;\n \ttype = type;\n \tpositionXY = positionXY;\n } </code> </pre> A więc wszystko nam działa, możemy tworzyć nowy <b>LEPSZY</b> projekt? No nie do końca. Bo może i pobieramy tylko w konstruktorze nasze dane ale zobaczcie że zmienne w klasie są tak samo nazwane jak argumenty w konstrukorze. I przy naszym zapisie ustawiamy wartość argumentu hp wartością argumentu hp! My chcemy zmienić zmienną!!! Co nam pozostaje? Jedynie skulić się w kulkę i cicho zapłakać? No nie. Wystarczy użyć słówka kluczowego this przed nazwą zmiennej z klasy. Oznaczać to będzie że chcemy użyć zmiennej spoza naszego konstruktora. Wtedy kod będzie wyglądać tak: <pre> <code class=\"hljs java\"> Monster(int hp, String type, int[] positionXY){\n \tthis.hp = hp;\n \tthis.type = type;\n \tthis.positionXY = positionXY;\n } </code> </pre> Jednak co jeżeli chcemy używać równierz domyślnego konstruktora? Wtedy wyskoczy nam błąd! Lecz to nie tak że nie możemy mieć wielu konstruktorów. Po prostu jeżeli mamy jakikolwiek konstruktor zapisany w naszej klasie, wtedy ten nasz pusty się nie tworzy, więc wystarczy dopisać do naszej klasy coś takiego: <pre> <code class=\"hljs java\"> Monster(){\n } </code> </pre> Wróćmy zatem do naszej klasy głównej. Zmieńmy dla naszego slime konstruktor, jednak dla zombie zostawmy stary. Teraz kod będzie wyglądać tak: <pre> <code class=\"hljs java\"> public class Main{\tpublic static void main(String[] args){\n \n \t\tMonster slime = new Monster(50, \"slime\", new int[]{50, -15});\n \t\tslime.spawnMonster();\n \n \t\tMonster zombie = new Monster();\n \t\tzombie.type = \"zombie\";\n \t\tzombie.hp = 253;\n \t\tzombie.positionXY = new int[]{515, 732};\n \t\tzombie.spawnMonster();\n \n \t}\n \n } </code> </pre> Mi się bardziej podoba zapis obiektu <b>slime</b>, jednak każdy ma swoje upodobania.",
        "title": "Klasy w Javie"
    },
    {
        "id": 7,
        "description": "W tym artykule mówię o dziedziczeniu klas. Po przeczytaniu go będziesz wiedział czym jest dziedziczenie i jak je wykorzystywać.",
        "content": "<h2>Co to dziedziczenie?</h2> Dziedziczenie klas to otrzymanie wszystkich zmiennych i metod z danej klasy. <b>Subklasa</b>(klasa która dziedziczy) może rozszerzyć zawartość <b>super klasy</b>(klasa która jest dziedziczona). Po co się to robi byście zapytali? A co jeżeli tworzymy aplikację mobilną? Na pewno mamy w niej tak zwane <b>activites</b>. Są to takie punkty docelowe w naszel aplikacji. Dzieli się ona na plik xml i na klase javy która jest właśnie rozszerzona klasą <b>Activity</b>, w której są różne metody pozwalające działać naszej aplikacji. Tam też się ustala który dokładnie plik xml jest plikiem naszej activity. <pre> <code class=\"hljs java\"> public class MainActivity extends Activity {\n ...\n } </code> </pre> Aby rozszerzyć daną klasę, do subklasy musimy dopisać <b>extends</b> a po tym naszą super klasę. Skoro już troszkę o tym lizneliżmy, to napiszmy coś. <h2>Użycie dziedziczenia</h2> Napiszemy program konsolowy który będzie wypisywał logi w trakcie zmian w naszej aplikacji. Co będzie się zmieniać? No uznajmy że typ okna aplikacji. <pre> <code class=\"hljs java\"> public abstract class Okno {\n \n \tpublic int appWidth = 0;\n \tpublic int appHeight = 0;\n \n \tfinal void show() {\n \t\tif(appHeight>=0&&appWidth>=0) {\n \t\t\tSystem.out.println(\"Set window!\");\n \t\t\tSystem.out.println(\"Width: \" + appWidth);\n \t\t\tSystem.out.println(\"Height: \" + appHeight);\n \t\t\tinside(appWidth, appHeight);\n \t\t} else if(appWidth==0){\n \t\t\tSystem.err.println(\"Width of application can't equals 0!\");\n \t\t\tSystem.exit(-1);\n \t\t}else if(appHeight==0){\n \t\t\tSystem.err.println(\"Height of application can't equals 0!\");\n \t\t\tSystem.exit(-1);\n \t\t}else if(appWidth&lt;0){\n \t\t\tSystem.err.println(\"Width of application can't be lower then 0!\");\n \t\t\tSystem.exit(-1);\n \t\t}else if(appHeight&lt;0){\n \t\t\tSystem.err.println(\"Height of application can't be lower then 0!\");\n \t\t\tSystem.exit(-1);\n \t\t}\n \t}\n \n \tvoid changeWindow(Object obj){\n \t\t((Okno)obj).show();\n \t}\n \n \tabstract void inside(int width, int height);\n } </code> </pre> Troszkę zawiła ta klasa więc opowiem z troszkę o niej. Najpierw tworzymy dwie zmienne odpowiadające rozdzielczości naszej aplikacji. Następnie tworzymy metodę ze słówkiem kluczowym <b>final</b> oznacza to że nie da się jej zmienić, więc w subklasie nie będzie można zmienić jej składni. W metodzie <i>show()</i> najpierw sprawdzamy czy nasze zmienne odpowiadające za rozmiar okna są większe od zera, jeżeli tak to wyświetlamy na ekranie na że ustawiliśmy okno o danej rozdzielczości a następnie wywołujemy metodę <i>inside</i>, lecz jeżeli te zmienne nie są większe od zera to wyświetlamy komunikat o błędzie i wyłączamy program. Następnie mamy metodę <b>changeWindow</b> przyjmującą obiekt klasy. W środku tej funkcji wyrażeniem <i>((Okno)obj)</i> rzutujemy nasz obiekt na klasę Okno a następnie wykonujemy na zrzutowanym obiekcie metode <i>show()</i> Przychodzi czas na ostatnią już metodę. Jest nią <i>inside</i>. Jak widzimy mamy w niej dziwne słówko kluczowe <b>abstract</b>. Ono mówi że w subklasach klasy Okno ta metoda musi być rozwinięta, bo jak widzimy nie ma ona ciała, jej ciało nadane zostanie dopiero w subklasie! Dobrze więc teraz możemy utworzyć klasę naszej aplikacji!<pre> <code class=\"hljs java\"> public class Aplikacja extends Okno {\n \n \t@Override\n \tvoid inside(int width, int height) {\n \t\tSystem.out.println(\"Work\");\n \n \t\tchangeWindow(new DrugaAplikacja());\n \t}\n } </code> </pre> W naszej subklasie widzimy oznaczenie <b>@Override</b>, oznacza ono że ta metoda jest napisywana. W środku naszej metody inside wyświetliłem napis <i>work</i>. Następnie przy pomocy metody <i>changeWindow</i> zmieniłem okno na drugą klase. W tym celu utworzyłem nowy obiekt klasy <i>DrugaAplikacja</i>. Jej zawartość to: <pre> <code class=\"hljs java\"> public class DrugaAplikacja extends Okno {\n \n \t@Override\n \tvoid inside(int width, int height) {\n \t\tSystem.out.println(\"Druga!\");\n \t}\n \n } </code> </pre> W niej mamy tylko metodę <i>inside</i> w której wyświetlamy napis <i>Druga!</i>. Dobrze dotarliśmy wreście do naszej głównej klasy. <pre> <code class=\"hljs java\"> public class Main {\n \n \tpublic static void main(String[] args){\n \n \t\tAplikacja app = new Aplikacja();\n \t\tapp.appHeight = 500;\n \t\tapp.appWidth = 750;\n \t\tapp.show();\n\n \n \t}\n \n } </code> </pre> W tej klasie mamy główną metodę w której utworzyłem obiekt aplikacji a następnie ustawiłem rozdzielczość ekranu. Na koniec wywołałem funkcję <i>show()</i>. Jako iż nie ustawiłem nigdzie rodzielczości dla drugiej aplikacji to wywala błąd. <pre> <code class=\"hljs\"> Output: \n Set window!\n Width: 750\n Height: 500\n Work\n <span style=\"color: red;\">Width of application can't equals 0!</span> </code> </pre>",
        "title": "Dziedziczenie w Javie"
    },
    {
        "id": 8,
        "description": "Artykuł ten jest poświęcony klasom typu enum. Po przeczytaniu go będziesz wiedział jak z nich korzystać.",
        "content": " <h2>Co to ENUM?</h2> Jeżeli kiedyś coś słyszeliście o enumach to napewno usłyszaliście taką frazę \"enum to typ wyliczeniowy\". Dużo osób myśli że to jest specjalna klasa do liczenia. <b>OTÓŻ NIE TYM RAZEM</b>. Enum to typ klasy w którym jedyne co się tworzy to stałe. Stałe które nie posiadają wartości, znaczy <b>niby</b> nie posiadają. To działa tak że one się od siebie różnią, ale nie da się nadać im wartości. Dzięki temu funkcja może odróżnić czy jakaś zmienna jest równa stałej z enuma. Jak już wspomniałem enum to typ klasy, deklaruje się go tak samo jak klasę, różnica jest taka że nie używa się słówka <b>class</b> a <b>enum</b>.<pre> <code class=\"hljs java\"> public enum [nazwa]{\n ...\n } </code> </pre> Stałe w enumie wypisuje się wielkimi literami(jak to stałe) i po przecinku. Tak jak na poniższym przykładzie: <pre> <code class=\"hljs java\"> public enum Przykład{\n \tZMIENNA, DRUGA, TRZECIA\n } </code> </pre> <h2>Trochę praktyki</h2> Nie wiem czy też tak macie, ale wymyślanie przykładów dla mnie jest strasznie trudne. Dlatego dzisiaj przykład będzie strasznie niepraktyczny. Nasz program będzie wyświetlał tekst o danym kolorze. Nasz enum będzie posiadać kolory tekstu, będzie on wyklądać o tak: <pre> <code class=\"hljs java\"> public enum ColorType {\n \n \tDEFAULT, RED, GREEN, BLUE\n \n } </code> </pre> Teraz przejdźmy do głównej klasy. Najpierw wyświetlimy wszystkie kolory w pętli foreach. Następnie używamy funkcji która nazywa się <b>write</b> i przyjmuje dwa parametry. Pierwszy to typ enum, a drugi to tekst. W funkcji <b>write</b> używając <i>switch case</i> sprawdzam jaki jest enum i do danego typu wypisuje kolor konsolowy przy pomocy standardu ANSI. Potem wypisuje tekst. Opisałem wam jak będzie wyglądać główna klasa to teraz przejde do enuma. <pre> <code class=\"hljs java\"> public class Main {\n \n \tpublic static void main(String[] args){\n \n \t\tfor (ColorType type: ColorType.values()){\n \t\t\tSystem.out.println(type.name());\n \t\t}\n \n \n \t\twrite(ColorType.RED, \"Typical text\");\n \n \t}\n \n \tprivate static void write(ColorType type, String text){\n \t\tswitch (type){\n \t\t\tcase DEFAULT:\n \t\t\t\tSystem.out.print(\"\\u001B[0m\");\n \t\t\t\tbreak;\n \t\t\tcase RED:\n \t\t\t\tSystem.out.print(\"\\u001B[31m\");\n \t\t\t\tbreak;\n \t\t\tcase GREEN:\n \t\t\t\tSystem.out.print(\"\\u001B[32m\");\n \t\t\t\tbreak;\n \t\t\tcase BLUE:\n \t\t\t\tSystem.out.print(\"\\u001B[34m\");\n \t\t\t\tbreak;\n \t\t}\n \t\tSystem.out.println(text);\n \t}\n \n } </code> </pre> Najpierw w głównej funkcji wyświetlam elementy przy użyciu foreach. Zapis ten oznacza że tworzymy zmienną klasy ColorType która nazywa się type i jest zmieniana przy każdym ruchu pętli na element z tablicy którą zwraca metoda <b>value()</b> którą posiada każda klasa enum. Potem używamy funkcji <b>write</b> ze stałą <b>RED</b> i tekstem <i>Typical text</i>. Potem w funkcji wypisujemy metodą <b>System.out.print()</b> wartość ASNI na ekran(jest ona nie widzialna dla użytkownika, zmienia ona cały tekst po niej). A następnie wyświetlamy teskt. Jak możecie zauważyć nie musiałem pisać <b>ColorType.RED</b> w środku <i>switch case'a</i>, ponieważ typ zmiennej type to <b>ColorTyle</b> to java wie że to musi być stała z ów enuma. Ahhh jaka mądra ta Java. Po uruchomieniu programu otrzymamy taki wynik: <pre> <code class=\"hljs\"> DEFAULT\n RED\n GREEN\n BLUE\n <span style=\"color: red;\">Typical text</span> </code> </pre>",
        "title": "Typ ENUM - Java"
    }
]